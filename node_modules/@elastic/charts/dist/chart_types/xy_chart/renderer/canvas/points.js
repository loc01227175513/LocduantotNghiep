"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderPoints = renderPoints;
exports.renderPointGroup = renderPointGroup;
const panel_clipping_1 = require("./panel_clipping");
const shapes_1 = require("./primitives/shapes");
const panel_transform_1 = require("./utils/panel_transform");
const color_library_wrappers_1 = require("../../../../common/color_library_wrappers");
const points_1 = require("../../rendering/points");
function renderPoints(ctx, points, { opacity }, pointStyle, lineStrokeWidth, minDistanceBetweenPoints, minDistanceToShowPoints, hasConnectingLine) {
    const isHiddenOnAuto = pointStyle.visible === 'auto' && minDistanceBetweenPoints < minDistanceToShowPoints;
    const hideDataPoints = pointStyle.visible === 'never' || isHiddenOnAuto;
    const hideIsolatedDataPoints = hasConnectingLine && hideDataPoints;
    const useIsolatedPointRadius = hideDataPoints && !hasConnectingLine;
    points.forEach(({ x, y, radius, transform, style, isolated }) => {
        if ((isolated && hideIsolatedDataPoints) || (!isolated && hideDataPoints)) {
            return;
        }
        const coordinates = {
            x: x + transform.x,
            y: y + transform.y,
            radius: isolated ? (useIsolatedPointRadius ? (0, points_1.isolatedPointRadius)(lineStrokeWidth) : pointStyle.radius) : radius,
        };
        const fill = { color: (0, color_library_wrappers_1.overrideOpacity)(style.fill.color, (fillOpacity) => fillOpacity * opacity) };
        const stroke = {
            ...style.stroke,
            color: (0, color_library_wrappers_1.overrideOpacity)(style.stroke.color, (fillOpacity) => fillOpacity * opacity),
        };
        (0, shapes_1.renderShape)(ctx, style.shape, coordinates, fill, stroke);
    });
}
function renderPointGroup(ctx, points, geometryStateStyles, rotation, renderingArea, shouldClip) {
    points
        .slice()
        .sort(({ radius: a }, { radius: b }) => b - a)
        .forEach(({ x, y, radius, transform, style, seriesIdentifier: { key }, panel }) => {
        var _a, _b;
        const opacity = (_b = (_a = geometryStateStyles[key]) === null || _a === void 0 ? void 0 : _a.opacity) !== null && _b !== void 0 ? _b : 1;
        const fill = { color: (0, color_library_wrappers_1.overrideOpacity)(style.fill.color, (fillOpacity) => fillOpacity * opacity) };
        const stroke = {
            ...style.stroke,
            color: (0, color_library_wrappers_1.overrideOpacity)(style.stroke.color, (fillOpacity) => fillOpacity * opacity),
        };
        const coordinates = { x: x + transform.x, y, radius };
        const renderer = () => (0, shapes_1.renderShape)(ctx, style.shape, coordinates, fill, stroke);
        const clippings = { area: (0, panel_clipping_1.getPanelClipping)(panel, rotation), shouldClip };
        (0, panel_transform_1.withPanelTransform)(ctx, panel, rotation, renderingArea, renderer, clippings);
    });
}
//# sourceMappingURL=points.js.map