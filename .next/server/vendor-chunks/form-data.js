/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/form-data";
exports.ids = ["vendor-chunks/form-data"];
exports.modules = {

/***/ "(ssr)/./node_modules/form-data/lib/form_data.js":
/*!*************************************************!*\
  !*** ./node_modules/form-data/lib/form_data.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var CombinedStream = __webpack_require__(/*! combined-stream */ \"(ssr)/./node_modules/combined-stream/lib/combined_stream.js\");\r\nvar util = __webpack_require__(/*! util */ \"util\");\r\nvar path = __webpack_require__(/*! path */ \"path\");\r\nvar http = __webpack_require__(/*! http */ \"http\");\r\nvar https = __webpack_require__(/*! https */ \"https\");\r\nvar parseUrl = (__webpack_require__(/*! url */ \"url\").parse);\r\nvar fs = __webpack_require__(/*! fs */ \"fs\");\r\nvar Stream = (__webpack_require__(/*! stream */ \"stream\").Stream);\r\nvar mime = __webpack_require__(/*! mime-types */ \"(ssr)/./node_modules/mime-types/index.js\");\r\nvar asynckit = __webpack_require__(/*! asynckit */ \"(ssr)/./node_modules/asynckit/index.js\");\r\nvar populate = __webpack_require__(/*! ./populate.js */ \"(ssr)/./node_modules/form-data/lib/populate.js\");\r\n\r\n// Public API\r\nmodule.exports = FormData;\r\n\r\n// make it a Stream\r\nutil.inherits(FormData, CombinedStream);\r\n\r\n/**\r\n * Create readable \"multipart/form-data\" streams.\r\n * Can be used to submit forms\r\n * and file uploads to other web applications.\r\n *\r\n * @constructor\r\n * @param {Object} options - Properties to be added/overriden for FormData and CombinedStream\r\n */\r\nfunction FormData(options) {\r\n  if (!(this instanceof FormData)) {\r\n    return new FormData(options);\r\n  }\r\n\r\n  this._overheadLength = 0;\r\n  this._valueLength = 0;\r\n  this._valuesToMeasure = [];\r\n\r\n  CombinedStream.call(this);\r\n\r\n  options = options || {};\r\n  for (var option in options) {\r\n    this[option] = options[option];\r\n  }\r\n}\r\n\r\nFormData.LINE_BREAK = '\\r\\n';\r\nFormData.DEFAULT_CONTENT_TYPE = 'application/octet-stream';\r\n\r\nFormData.prototype.append = function(field, value, options) {\r\n\r\n  options = options || {};\r\n\r\n  // allow filename as single option\r\n  if (typeof options == 'string') {\r\n    options = {filename: options};\r\n  }\r\n\r\n  var append = CombinedStream.prototype.append.bind(this);\r\n\r\n  // all that streamy business can't handle numbers\r\n  if (typeof value == 'number') {\r\n    value = '' + value;\r\n  }\r\n\r\n  // https://github.com/felixge/node-form-data/issues/38\r\n  if (Array.isArray(value)) {\r\n    // Please convert your array into string\r\n    // the way web server expects it\r\n    this._error(new Error('Arrays are not supported.'));\r\n    return;\r\n  }\r\n\r\n  var header = this._multiPartHeader(field, value, options);\r\n  var footer = this._multiPartFooter();\r\n\r\n  append(header);\r\n  append(value);\r\n  append(footer);\r\n\r\n  // pass along options.knownLength\r\n  this._trackLength(header, value, options);\r\n};\r\n\r\nFormData.prototype._trackLength = function(header, value, options) {\r\n  var valueLength = 0;\r\n\r\n  // used w/ getLengthSync(), when length is known.\r\n  // e.g. for streaming directly from a remote server,\r\n  // w/ a known file a size, and not wanting to wait for\r\n  // incoming file to finish to get its size.\r\n  if (options.knownLength != null) {\r\n    valueLength += +options.knownLength;\r\n  } else if (Buffer.isBuffer(value)) {\r\n    valueLength = value.length;\r\n  } else if (typeof value === 'string') {\r\n    valueLength = Buffer.byteLength(value);\r\n  }\r\n\r\n  this._valueLength += valueLength;\r\n\r\n  // @check why add CRLF? does this account for custom/multiple CRLFs?\r\n  this._overheadLength +=\r\n    Buffer.byteLength(header) +\r\n    FormData.LINE_BREAK.length;\r\n\r\n  // empty or either doesn't have path or not an http response or not a stream\r\n  if (!value || ( !value.path && !(value.readable && value.hasOwnProperty('httpVersion')) && !(value instanceof Stream))) {\r\n    return;\r\n  }\r\n\r\n  // no need to bother with the length\r\n  if (!options.knownLength) {\r\n    this._valuesToMeasure.push(value);\r\n  }\r\n};\r\n\r\nFormData.prototype._lengthRetriever = function(value, callback) {\r\n\r\n  if (value.hasOwnProperty('fd')) {\r\n\r\n    // take read range into a account\r\n    // `end` = Infinity â€“> read file till the end\r\n    //\r\n    // TODO: Looks like there is bug in Node fs.createReadStream\r\n    // it doesn't respect `end` options without `start` options\r\n    // Fix it when node fixes it.\r\n    // https://github.com/joyent/node/issues/7819\r\n    if (value.end != undefined && value.end != Infinity && value.start != undefined) {\r\n\r\n      // when end specified\r\n      // no need to calculate range\r\n      // inclusive, starts with 0\r\n      callback(null, value.end + 1 - (value.start ? value.start : 0));\r\n\r\n    // not that fast snoopy\r\n    } else {\r\n      // still need to fetch file size from fs\r\n      fs.stat(value.path, function(err, stat) {\r\n\r\n        var fileSize;\r\n\r\n        if (err) {\r\n          callback(err);\r\n          return;\r\n        }\r\n\r\n        // update final size based on the range options\r\n        fileSize = stat.size - (value.start ? value.start : 0);\r\n        callback(null, fileSize);\r\n      });\r\n    }\r\n\r\n  // or http response\r\n  } else if (value.hasOwnProperty('httpVersion')) {\r\n    callback(null, +value.headers['content-length']);\r\n\r\n  // or request stream http://github.com/mikeal/request\r\n  } else if (value.hasOwnProperty('httpModule')) {\r\n    // wait till response come back\r\n    value.on('response', function(response) {\r\n      value.pause();\r\n      callback(null, +response.headers['content-length']);\r\n    });\r\n    value.resume();\r\n\r\n  // something else\r\n  } else {\r\n    callback('Unknown stream');\r\n  }\r\n};\r\n\r\nFormData.prototype._multiPartHeader = function(field, value, options) {\r\n  // custom header specified (as string)?\r\n  // it becomes responsible for boundary\r\n  // (e.g. to handle extra CRLFs on .NET servers)\r\n  if (typeof options.header == 'string') {\r\n    return options.header;\r\n  }\r\n\r\n  var contentDisposition = this._getContentDisposition(value, options);\r\n  var contentType = this._getContentType(value, options);\r\n\r\n  var contents = '';\r\n  var headers  = {\r\n    // add custom disposition as third element or keep it two elements if not\r\n    'Content-Disposition': ['form-data', 'name=\"' + field + '\"'].concat(contentDisposition || []),\r\n    // if no content type. allow it to be empty array\r\n    'Content-Type': [].concat(contentType || [])\r\n  };\r\n\r\n  // allow custom headers.\r\n  if (typeof options.header == 'object') {\r\n    populate(headers, options.header);\r\n  }\r\n\r\n  var header;\r\n  for (var prop in headers) {\r\n    if (!headers.hasOwnProperty(prop)) continue;\r\n    header = headers[prop];\r\n\r\n    // skip nullish headers.\r\n    if (header == null) {\r\n      continue;\r\n    }\r\n\r\n    // convert all headers to arrays.\r\n    if (!Array.isArray(header)) {\r\n      header = [header];\r\n    }\r\n\r\n    // add non-empty headers.\r\n    if (header.length) {\r\n      contents += prop + ': ' + header.join('; ') + FormData.LINE_BREAK;\r\n    }\r\n  }\r\n\r\n  return '--' + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;\r\n};\r\n\r\nFormData.prototype._getContentDisposition = function(value, options) {\r\n\r\n  var filename\r\n    , contentDisposition\r\n    ;\r\n\r\n  if (typeof options.filepath === 'string') {\r\n    // custom filepath for relative paths\r\n    filename = path.normalize(options.filepath).replace(/\\\\/g, '/');\r\n  } else if (options.filename || value.name || value.path) {\r\n    // custom filename take precedence\r\n    // formidable and the browser add a name property\r\n    // fs- and request- streams have path property\r\n    filename = path.basename(options.filename || value.name || value.path);\r\n  } else if (value.readable && value.hasOwnProperty('httpVersion')) {\r\n    // or try http response\r\n    filename = path.basename(value.client._httpMessage.path || '');\r\n  }\r\n\r\n  if (filename) {\r\n    contentDisposition = 'filename=\"' + filename + '\"';\r\n  }\r\n\r\n  return contentDisposition;\r\n};\r\n\r\nFormData.prototype._getContentType = function(value, options) {\r\n\r\n  // use custom content-type above all\r\n  var contentType = options.contentType;\r\n\r\n  // or try `name` from formidable, browser\r\n  if (!contentType && value.name) {\r\n    contentType = mime.lookup(value.name);\r\n  }\r\n\r\n  // or try `path` from fs-, request- streams\r\n  if (!contentType && value.path) {\r\n    contentType = mime.lookup(value.path);\r\n  }\r\n\r\n  // or if it's http-reponse\r\n  if (!contentType && value.readable && value.hasOwnProperty('httpVersion')) {\r\n    contentType = value.headers['content-type'];\r\n  }\r\n\r\n  // or guess it from the filepath or filename\r\n  if (!contentType && (options.filepath || options.filename)) {\r\n    contentType = mime.lookup(options.filepath || options.filename);\r\n  }\r\n\r\n  // fallback to the default content type if `value` is not simple value\r\n  if (!contentType && typeof value == 'object') {\r\n    contentType = FormData.DEFAULT_CONTENT_TYPE;\r\n  }\r\n\r\n  return contentType;\r\n};\r\n\r\nFormData.prototype._multiPartFooter = function() {\r\n  return function(next) {\r\n    var footer = FormData.LINE_BREAK;\r\n\r\n    var lastPart = (this._streams.length === 0);\r\n    if (lastPart) {\r\n      footer += this._lastBoundary();\r\n    }\r\n\r\n    next(footer);\r\n  }.bind(this);\r\n};\r\n\r\nFormData.prototype._lastBoundary = function() {\r\n  return '--' + this.getBoundary() + '--' + FormData.LINE_BREAK;\r\n};\r\n\r\nFormData.prototype.getHeaders = function(userHeaders) {\r\n  var header;\r\n  var formHeaders = {\r\n    'content-type': 'multipart/form-data; boundary=' + this.getBoundary()\r\n  };\r\n\r\n  for (header in userHeaders) {\r\n    if (userHeaders.hasOwnProperty(header)) {\r\n      formHeaders[header.toLowerCase()] = userHeaders[header];\r\n    }\r\n  }\r\n\r\n  return formHeaders;\r\n};\r\n\r\nFormData.prototype.setBoundary = function(boundary) {\r\n  this._boundary = boundary;\r\n};\r\n\r\nFormData.prototype.getBoundary = function() {\r\n  if (!this._boundary) {\r\n    this._generateBoundary();\r\n  }\r\n\r\n  return this._boundary;\r\n};\r\n\r\nFormData.prototype.getBuffer = function() {\r\n  var dataBuffer = new Buffer.alloc( 0 );\r\n  var boundary = this.getBoundary();\r\n\r\n  // Create the form content. Add Line breaks to the end of data.\r\n  for (var i = 0, len = this._streams.length; i < len; i++) {\r\n    if (typeof this._streams[i] !== 'function') {\r\n\r\n      // Add content to the buffer.\r\n      if(Buffer.isBuffer(this._streams[i])) {\r\n        dataBuffer = Buffer.concat( [dataBuffer, this._streams[i]]);\r\n      }else {\r\n        dataBuffer = Buffer.concat( [dataBuffer, Buffer.from(this._streams[i])]);\r\n      }\r\n\r\n      // Add break after content.\r\n      if (typeof this._streams[i] !== 'string' || this._streams[i].substring( 2, boundary.length + 2 ) !== boundary) {\r\n        dataBuffer = Buffer.concat( [dataBuffer, Buffer.from(FormData.LINE_BREAK)] );\r\n      }\r\n    }\r\n  }\r\n\r\n  // Add the footer and return the Buffer object.\r\n  return Buffer.concat( [dataBuffer, Buffer.from(this._lastBoundary())] );\r\n};\r\n\r\nFormData.prototype._generateBoundary = function() {\r\n  // This generates a 50 character boundary similar to those used by Firefox.\r\n  // They are optimized for boyer-moore parsing.\r\n  var boundary = '--------------------------';\r\n  for (var i = 0; i < 24; i++) {\r\n    boundary += Math.floor(Math.random() * 10).toString(16);\r\n  }\r\n\r\n  this._boundary = boundary;\r\n};\r\n\r\n// Note: getLengthSync DOESN'T calculate streams length\r\n// As workaround one can calculate file size manually\r\n// and add it as knownLength option\r\nFormData.prototype.getLengthSync = function() {\r\n  var knownLength = this._overheadLength + this._valueLength;\r\n\r\n  // Don't get confused, there are 3 \"internal\" streams for each keyval pair\r\n  // so it basically checks if there is any value added to the form\r\n  if (this._streams.length) {\r\n    knownLength += this._lastBoundary().length;\r\n  }\r\n\r\n  // https://github.com/form-data/form-data/issues/40\r\n  if (!this.hasKnownLength()) {\r\n    // Some async length retrievers are present\r\n    // therefore synchronous length calculation is false.\r\n    // Please use getLength(callback) to get proper length\r\n    this._error(new Error('Cannot calculate proper length in synchronous way.'));\r\n  }\r\n\r\n  return knownLength;\r\n};\r\n\r\n// Public API to check if length of added values is known\r\n// https://github.com/form-data/form-data/issues/196\r\n// https://github.com/form-data/form-data/issues/262\r\nFormData.prototype.hasKnownLength = function() {\r\n  var hasKnownLength = true;\r\n\r\n  if (this._valuesToMeasure.length) {\r\n    hasKnownLength = false;\r\n  }\r\n\r\n  return hasKnownLength;\r\n};\r\n\r\nFormData.prototype.getLength = function(cb) {\r\n  var knownLength = this._overheadLength + this._valueLength;\r\n\r\n  if (this._streams.length) {\r\n    knownLength += this._lastBoundary().length;\r\n  }\r\n\r\n  if (!this._valuesToMeasure.length) {\r\n    process.nextTick(cb.bind(this, null, knownLength));\r\n    return;\r\n  }\r\n\r\n  asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {\r\n    if (err) {\r\n      cb(err);\r\n      return;\r\n    }\r\n\r\n    values.forEach(function(length) {\r\n      knownLength += length;\r\n    });\r\n\r\n    cb(null, knownLength);\r\n  });\r\n};\r\n\r\nFormData.prototype.submit = function(params, cb) {\r\n  var request\r\n    , options\r\n    , defaults = {method: 'post'}\r\n    ;\r\n\r\n  // parse provided url if it's string\r\n  // or treat it as options object\r\n  if (typeof params == 'string') {\r\n\r\n    params = parseUrl(params);\r\n    options = populate({\r\n      port: params.port,\r\n      path: params.pathname,\r\n      host: params.hostname,\r\n      protocol: params.protocol\r\n    }, defaults);\r\n\r\n  // use custom params\r\n  } else {\r\n\r\n    options = populate(params, defaults);\r\n    // if no port provided use default one\r\n    if (!options.port) {\r\n      options.port = options.protocol == 'https:' ? 443 : 80;\r\n    }\r\n  }\r\n\r\n  // put that good code in getHeaders to some use\r\n  options.headers = this.getHeaders(params.headers);\r\n\r\n  // https if specified, fallback to http in any other case\r\n  if (options.protocol == 'https:') {\r\n    request = https.request(options);\r\n  } else {\r\n    request = http.request(options);\r\n  }\r\n\r\n  // get content length and fire away\r\n  this.getLength(function(err, length) {\r\n    if (err && err !== 'Unknown stream') {\r\n      this._error(err);\r\n      return;\r\n    }\r\n\r\n    // add content length\r\n    if (length) {\r\n      request.setHeader('Content-Length', length);\r\n    }\r\n\r\n    this.pipe(request);\r\n    if (cb) {\r\n      var onResponse;\r\n\r\n      var callback = function (error, responce) {\r\n        request.removeListener('error', callback);\r\n        request.removeListener('response', onResponse);\r\n\r\n        return cb.call(this, error, responce);\r\n      };\r\n\r\n      onResponse = callback.bind(this, null);\r\n\r\n      request.on('error', callback);\r\n      request.on('response', onResponse);\r\n    }\r\n  }.bind(this));\r\n\r\n  return request;\r\n};\r\n\r\nFormData.prototype._error = function(err) {\r\n  if (!this.error) {\r\n    this.error = err;\r\n    this.pause();\r\n    this.emit('error', err);\r\n  }\r\n};\r\n\r\nFormData.prototype.toString = function () {\r\n  return '[object FormData]';\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZm9ybS1kYXRhL2xpYi9mb3JtX2RhdGEuanMiLCJtYXBwaW5ncyI6IkFBQUEscUJBQXFCLG1CQUFPLENBQUMsb0ZBQWlCO0FBQzlDLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QixXQUFXLG1CQUFPLENBQUMsa0JBQU07QUFDekIsV0FBVyxtQkFBTyxDQUFDLGtCQUFNO0FBQ3pCLFlBQVksbUJBQU8sQ0FBQyxvQkFBTztBQUMzQixlQUFlLDZDQUFvQjtBQUNuQyxTQUFTLG1CQUFPLENBQUMsY0FBSTtBQUNyQixhQUFhLG9EQUF3QjtBQUNyQyxXQUFXLG1CQUFPLENBQUMsNERBQVk7QUFDL0IsZUFBZSxtQkFBTyxDQUFDLHdEQUFVO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyxxRUFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFNBQVM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXHhhbXBwXFxodGRvY3NcXER1QW5Ub3ROZ2hpZXBcXEhvc3RpbmdcXHRlY2hzdHVkZW50LWRhdG4gLSBDb3B5XFxhYWFhYWFhYWFhXFxMb2NkdWFudG90TmdoaWVwXFxMb2NkdWFudG90TmdoaWVwXFxub2RlX21vZHVsZXNcXGZvcm0tZGF0YVxcbGliXFxmb3JtX2RhdGEuanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIENvbWJpbmVkU3RyZWFtID0gcmVxdWlyZSgnY29tYmluZWQtc3RyZWFtJyk7XHJcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xyXG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcclxudmFyIGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XHJcbnZhciBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyk7XHJcbnZhciBwYXJzZVVybCA9IHJlcXVpcmUoJ3VybCcpLnBhcnNlO1xyXG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xyXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJykuU3RyZWFtO1xyXG52YXIgbWltZSA9IHJlcXVpcmUoJ21pbWUtdHlwZXMnKTtcclxudmFyIGFzeW5ja2l0ID0gcmVxdWlyZSgnYXN5bmNraXQnKTtcclxudmFyIHBvcHVsYXRlID0gcmVxdWlyZSgnLi9wb3B1bGF0ZS5qcycpO1xyXG5cclxuLy8gUHVibGljIEFQSVxyXG5tb2R1bGUuZXhwb3J0cyA9IEZvcm1EYXRhO1xyXG5cclxuLy8gbWFrZSBpdCBhIFN0cmVhbVxyXG51dGlsLmluaGVyaXRzKEZvcm1EYXRhLCBDb21iaW5lZFN0cmVhbSk7XHJcblxyXG4vKipcclxuICogQ3JlYXRlIHJlYWRhYmxlIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiIHN0cmVhbXMuXHJcbiAqIENhbiBiZSB1c2VkIHRvIHN1Ym1pdCBmb3Jtc1xyXG4gKiBhbmQgZmlsZSB1cGxvYWRzIHRvIG90aGVyIHdlYiBhcHBsaWNhdGlvbnMuXHJcbiAqXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFByb3BlcnRpZXMgdG8gYmUgYWRkZWQvb3ZlcnJpZGVuIGZvciBGb3JtRGF0YSBhbmQgQ29tYmluZWRTdHJlYW1cclxuICovXHJcbmZ1bmN0aW9uIEZvcm1EYXRhKG9wdGlvbnMpIHtcclxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRm9ybURhdGEpKSB7XHJcbiAgICByZXR1cm4gbmV3IEZvcm1EYXRhKG9wdGlvbnMpO1xyXG4gIH1cclxuXHJcbiAgdGhpcy5fb3ZlcmhlYWRMZW5ndGggPSAwO1xyXG4gIHRoaXMuX3ZhbHVlTGVuZ3RoID0gMDtcclxuICB0aGlzLl92YWx1ZXNUb01lYXN1cmUgPSBbXTtcclxuXHJcbiAgQ29tYmluZWRTdHJlYW0uY2FsbCh0aGlzKTtcclxuXHJcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgZm9yICh2YXIgb3B0aW9uIGluIG9wdGlvbnMpIHtcclxuICAgIHRoaXNbb3B0aW9uXSA9IG9wdGlvbnNbb3B0aW9uXTtcclxuICB9XHJcbn1cclxuXHJcbkZvcm1EYXRhLkxJTkVfQlJFQUsgPSAnXFxyXFxuJztcclxuRm9ybURhdGEuREVGQVVMVF9DT05URU5UX1RZUEUgPSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJztcclxuXHJcbkZvcm1EYXRhLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihmaWVsZCwgdmFsdWUsIG9wdGlvbnMpIHtcclxuXHJcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gIC8vIGFsbG93IGZpbGVuYW1lIGFzIHNpbmdsZSBvcHRpb25cclxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT0gJ3N0cmluZycpIHtcclxuICAgIG9wdGlvbnMgPSB7ZmlsZW5hbWU6IG9wdGlvbnN9O1xyXG4gIH1cclxuXHJcbiAgdmFyIGFwcGVuZCA9IENvbWJpbmVkU3RyZWFtLnByb3RvdHlwZS5hcHBlbmQuYmluZCh0aGlzKTtcclxuXHJcbiAgLy8gYWxsIHRoYXQgc3RyZWFteSBidXNpbmVzcyBjYW4ndCBoYW5kbGUgbnVtYmVyc1xyXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcclxuICAgIHZhbHVlID0gJycgKyB2YWx1ZTtcclxuICB9XHJcblxyXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZWxpeGdlL25vZGUtZm9ybS1kYXRhL2lzc3Vlcy8zOFxyXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgLy8gUGxlYXNlIGNvbnZlcnQgeW91ciBhcnJheSBpbnRvIHN0cmluZ1xyXG4gICAgLy8gdGhlIHdheSB3ZWIgc2VydmVyIGV4cGVjdHMgaXRcclxuICAgIHRoaXMuX2Vycm9yKG5ldyBFcnJvcignQXJyYXlzIGFyZSBub3Qgc3VwcG9ydGVkLicpKTtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIHZhciBoZWFkZXIgPSB0aGlzLl9tdWx0aVBhcnRIZWFkZXIoZmllbGQsIHZhbHVlLCBvcHRpb25zKTtcclxuICB2YXIgZm9vdGVyID0gdGhpcy5fbXVsdGlQYXJ0Rm9vdGVyKCk7XHJcblxyXG4gIGFwcGVuZChoZWFkZXIpO1xyXG4gIGFwcGVuZCh2YWx1ZSk7XHJcbiAgYXBwZW5kKGZvb3Rlcik7XHJcblxyXG4gIC8vIHBhc3MgYWxvbmcgb3B0aW9ucy5rbm93bkxlbmd0aFxyXG4gIHRoaXMuX3RyYWNrTGVuZ3RoKGhlYWRlciwgdmFsdWUsIG9wdGlvbnMpO1xyXG59O1xyXG5cclxuRm9ybURhdGEucHJvdG90eXBlLl90cmFja0xlbmd0aCA9IGZ1bmN0aW9uKGhlYWRlciwgdmFsdWUsIG9wdGlvbnMpIHtcclxuICB2YXIgdmFsdWVMZW5ndGggPSAwO1xyXG5cclxuICAvLyB1c2VkIHcvIGdldExlbmd0aFN5bmMoKSwgd2hlbiBsZW5ndGggaXMga25vd24uXHJcbiAgLy8gZS5nLiBmb3Igc3RyZWFtaW5nIGRpcmVjdGx5IGZyb20gYSByZW1vdGUgc2VydmVyLFxyXG4gIC8vIHcvIGEga25vd24gZmlsZSBhIHNpemUsIGFuZCBub3Qgd2FudGluZyB0byB3YWl0IGZvclxyXG4gIC8vIGluY29taW5nIGZpbGUgdG8gZmluaXNoIHRvIGdldCBpdHMgc2l6ZS5cclxuICBpZiAob3B0aW9ucy5rbm93bkxlbmd0aCAhPSBudWxsKSB7XHJcbiAgICB2YWx1ZUxlbmd0aCArPSArb3B0aW9ucy5rbm93bkxlbmd0aDtcclxuICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcclxuICAgIHZhbHVlTGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xyXG4gICAgdmFsdWVMZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWx1ZSk7XHJcbiAgfVxyXG5cclxuICB0aGlzLl92YWx1ZUxlbmd0aCArPSB2YWx1ZUxlbmd0aDtcclxuXHJcbiAgLy8gQGNoZWNrIHdoeSBhZGQgQ1JMRj8gZG9lcyB0aGlzIGFjY291bnQgZm9yIGN1c3RvbS9tdWx0aXBsZSBDUkxGcz9cclxuICB0aGlzLl9vdmVyaGVhZExlbmd0aCArPVxyXG4gICAgQnVmZmVyLmJ5dGVMZW5ndGgoaGVhZGVyKSArXHJcbiAgICBGb3JtRGF0YS5MSU5FX0JSRUFLLmxlbmd0aDtcclxuXHJcbiAgLy8gZW1wdHkgb3IgZWl0aGVyIGRvZXNuJ3QgaGF2ZSBwYXRoIG9yIG5vdCBhbiBodHRwIHJlc3BvbnNlIG9yIG5vdCBhIHN0cmVhbVxyXG4gIGlmICghdmFsdWUgfHwgKCAhdmFsdWUucGF0aCAmJiAhKHZhbHVlLnJlYWRhYmxlICYmIHZhbHVlLmhhc093blByb3BlcnR5KCdodHRwVmVyc2lvbicpKSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgU3RyZWFtKSkpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIC8vIG5vIG5lZWQgdG8gYm90aGVyIHdpdGggdGhlIGxlbmd0aFxyXG4gIGlmICghb3B0aW9ucy5rbm93bkxlbmd0aCkge1xyXG4gICAgdGhpcy5fdmFsdWVzVG9NZWFzdXJlLnB1c2godmFsdWUpO1xyXG4gIH1cclxufTtcclxuXHJcbkZvcm1EYXRhLnByb3RvdHlwZS5fbGVuZ3RoUmV0cmlldmVyID0gZnVuY3Rpb24odmFsdWUsIGNhbGxiYWNrKSB7XHJcblxyXG4gIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgnZmQnKSkge1xyXG5cclxuICAgIC8vIHRha2UgcmVhZCByYW5nZSBpbnRvIGEgYWNjb3VudFxyXG4gICAgLy8gYGVuZGAgPSBJbmZpbml0eSDigJM+IHJlYWQgZmlsZSB0aWxsIHRoZSBlbmRcclxuICAgIC8vXHJcbiAgICAvLyBUT0RPOiBMb29rcyBsaWtlIHRoZXJlIGlzIGJ1ZyBpbiBOb2RlIGZzLmNyZWF0ZVJlYWRTdHJlYW1cclxuICAgIC8vIGl0IGRvZXNuJ3QgcmVzcGVjdCBgZW5kYCBvcHRpb25zIHdpdGhvdXQgYHN0YXJ0YCBvcHRpb25zXHJcbiAgICAvLyBGaXggaXQgd2hlbiBub2RlIGZpeGVzIGl0LlxyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy83ODE5XHJcbiAgICBpZiAodmFsdWUuZW5kICE9IHVuZGVmaW5lZCAmJiB2YWx1ZS5lbmQgIT0gSW5maW5pdHkgJiYgdmFsdWUuc3RhcnQgIT0gdW5kZWZpbmVkKSB7XHJcblxyXG4gICAgICAvLyB3aGVuIGVuZCBzcGVjaWZpZWRcclxuICAgICAgLy8gbm8gbmVlZCB0byBjYWxjdWxhdGUgcmFuZ2VcclxuICAgICAgLy8gaW5jbHVzaXZlLCBzdGFydHMgd2l0aCAwXHJcbiAgICAgIGNhbGxiYWNrKG51bGwsIHZhbHVlLmVuZCArIDEgLSAodmFsdWUuc3RhcnQgPyB2YWx1ZS5zdGFydCA6IDApKTtcclxuXHJcbiAgICAvLyBub3QgdGhhdCBmYXN0IHNub29weVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gc3RpbGwgbmVlZCB0byBmZXRjaCBmaWxlIHNpemUgZnJvbSBmc1xyXG4gICAgICBmcy5zdGF0KHZhbHVlLnBhdGgsIGZ1bmN0aW9uKGVyciwgc3RhdCkge1xyXG5cclxuICAgICAgICB2YXIgZmlsZVNpemU7XHJcblxyXG4gICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgIGNhbGxiYWNrKGVycik7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB1cGRhdGUgZmluYWwgc2l6ZSBiYXNlZCBvbiB0aGUgcmFuZ2Ugb3B0aW9uc1xyXG4gICAgICAgIGZpbGVTaXplID0gc3RhdC5zaXplIC0gKHZhbHVlLnN0YXJ0ID8gdmFsdWUuc3RhcnQgOiAwKTtcclxuICAgICAgICBjYWxsYmFjayhudWxsLCBmaWxlU2l6ZSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAvLyBvciBodHRwIHJlc3BvbnNlXHJcbiAgfSBlbHNlIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgnaHR0cFZlcnNpb24nKSkge1xyXG4gICAgY2FsbGJhY2sobnVsbCwgK3ZhbHVlLmhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ10pO1xyXG5cclxuICAvLyBvciByZXF1ZXN0IHN0cmVhbSBodHRwOi8vZ2l0aHViLmNvbS9taWtlYWwvcmVxdWVzdFxyXG4gIH0gZWxzZSBpZiAodmFsdWUuaGFzT3duUHJvcGVydHkoJ2h0dHBNb2R1bGUnKSkge1xyXG4gICAgLy8gd2FpdCB0aWxsIHJlc3BvbnNlIGNvbWUgYmFja1xyXG4gICAgdmFsdWUub24oJ3Jlc3BvbnNlJywgZnVuY3Rpb24ocmVzcG9uc2UpIHtcclxuICAgICAgdmFsdWUucGF1c2UoKTtcclxuICAgICAgY2FsbGJhY2sobnVsbCwgK3Jlc3BvbnNlLmhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ10pO1xyXG4gICAgfSk7XHJcbiAgICB2YWx1ZS5yZXN1bWUoKTtcclxuXHJcbiAgLy8gc29tZXRoaW5nIGVsc2VcclxuICB9IGVsc2Uge1xyXG4gICAgY2FsbGJhY2soJ1Vua25vd24gc3RyZWFtJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuRm9ybURhdGEucHJvdG90eXBlLl9tdWx0aVBhcnRIZWFkZXIgPSBmdW5jdGlvbihmaWVsZCwgdmFsdWUsIG9wdGlvbnMpIHtcclxuICAvLyBjdXN0b20gaGVhZGVyIHNwZWNpZmllZCAoYXMgc3RyaW5nKT9cclxuICAvLyBpdCBiZWNvbWVzIHJlc3BvbnNpYmxlIGZvciBib3VuZGFyeVxyXG4gIC8vIChlLmcuIHRvIGhhbmRsZSBleHRyYSBDUkxGcyBvbiAuTkVUIHNlcnZlcnMpXHJcbiAgaWYgKHR5cGVvZiBvcHRpb25zLmhlYWRlciA9PSAnc3RyaW5nJykge1xyXG4gICAgcmV0dXJuIG9wdGlvbnMuaGVhZGVyO1xyXG4gIH1cclxuXHJcbiAgdmFyIGNvbnRlbnREaXNwb3NpdGlvbiA9IHRoaXMuX2dldENvbnRlbnREaXNwb3NpdGlvbih2YWx1ZSwgb3B0aW9ucyk7XHJcbiAgdmFyIGNvbnRlbnRUeXBlID0gdGhpcy5fZ2V0Q29udGVudFR5cGUodmFsdWUsIG9wdGlvbnMpO1xyXG5cclxuICB2YXIgY29udGVudHMgPSAnJztcclxuICB2YXIgaGVhZGVycyAgPSB7XHJcbiAgICAvLyBhZGQgY3VzdG9tIGRpc3Bvc2l0aW9uIGFzIHRoaXJkIGVsZW1lbnQgb3Iga2VlcCBpdCB0d28gZWxlbWVudHMgaWYgbm90XHJcbiAgICAnQ29udGVudC1EaXNwb3NpdGlvbic6IFsnZm9ybS1kYXRhJywgJ25hbWU9XCInICsgZmllbGQgKyAnXCInXS5jb25jYXQoY29udGVudERpc3Bvc2l0aW9uIHx8IFtdKSxcclxuICAgIC8vIGlmIG5vIGNvbnRlbnQgdHlwZS4gYWxsb3cgaXQgdG8gYmUgZW1wdHkgYXJyYXlcclxuICAgICdDb250ZW50LVR5cGUnOiBbXS5jb25jYXQoY29udGVudFR5cGUgfHwgW10pXHJcbiAgfTtcclxuXHJcbiAgLy8gYWxsb3cgY3VzdG9tIGhlYWRlcnMuXHJcbiAgaWYgKHR5cGVvZiBvcHRpb25zLmhlYWRlciA9PSAnb2JqZWN0Jykge1xyXG4gICAgcG9wdWxhdGUoaGVhZGVycywgb3B0aW9ucy5oZWFkZXIpO1xyXG4gIH1cclxuXHJcbiAgdmFyIGhlYWRlcjtcclxuICBmb3IgKHZhciBwcm9wIGluIGhlYWRlcnMpIHtcclxuICAgIGlmICghaGVhZGVycy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgY29udGludWU7XHJcbiAgICBoZWFkZXIgPSBoZWFkZXJzW3Byb3BdO1xyXG5cclxuICAgIC8vIHNraXAgbnVsbGlzaCBoZWFkZXJzLlxyXG4gICAgaWYgKGhlYWRlciA9PSBudWxsKSB7XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGNvbnZlcnQgYWxsIGhlYWRlcnMgdG8gYXJyYXlzLlxyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGhlYWRlcikpIHtcclxuICAgICAgaGVhZGVyID0gW2hlYWRlcl07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYWRkIG5vbi1lbXB0eSBoZWFkZXJzLlxyXG4gICAgaWYgKGhlYWRlci5sZW5ndGgpIHtcclxuICAgICAgY29udGVudHMgKz0gcHJvcCArICc6ICcgKyBoZWFkZXIuam9pbignOyAnKSArIEZvcm1EYXRhLkxJTkVfQlJFQUs7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gJy0tJyArIHRoaXMuZ2V0Qm91bmRhcnkoKSArIEZvcm1EYXRhLkxJTkVfQlJFQUsgKyBjb250ZW50cyArIEZvcm1EYXRhLkxJTkVfQlJFQUs7XHJcbn07XHJcblxyXG5Gb3JtRGF0YS5wcm90b3R5cGUuX2dldENvbnRlbnREaXNwb3NpdGlvbiA9IGZ1bmN0aW9uKHZhbHVlLCBvcHRpb25zKSB7XHJcblxyXG4gIHZhciBmaWxlbmFtZVxyXG4gICAgLCBjb250ZW50RGlzcG9zaXRpb25cclxuICAgIDtcclxuXHJcbiAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbGVwYXRoID09PSAnc3RyaW5nJykge1xyXG4gICAgLy8gY3VzdG9tIGZpbGVwYXRoIGZvciByZWxhdGl2ZSBwYXRoc1xyXG4gICAgZmlsZW5hbWUgPSBwYXRoLm5vcm1hbGl6ZShvcHRpb25zLmZpbGVwYXRoKS5yZXBsYWNlKC9cXFxcL2csICcvJyk7XHJcbiAgfSBlbHNlIGlmIChvcHRpb25zLmZpbGVuYW1lIHx8IHZhbHVlLm5hbWUgfHwgdmFsdWUucGF0aCkge1xyXG4gICAgLy8gY3VzdG9tIGZpbGVuYW1lIHRha2UgcHJlY2VkZW5jZVxyXG4gICAgLy8gZm9ybWlkYWJsZSBhbmQgdGhlIGJyb3dzZXIgYWRkIGEgbmFtZSBwcm9wZXJ0eVxyXG4gICAgLy8gZnMtIGFuZCByZXF1ZXN0LSBzdHJlYW1zIGhhdmUgcGF0aCBwcm9wZXJ0eVxyXG4gICAgZmlsZW5hbWUgPSBwYXRoLmJhc2VuYW1lKG9wdGlvbnMuZmlsZW5hbWUgfHwgdmFsdWUubmFtZSB8fCB2YWx1ZS5wYXRoKTtcclxuICB9IGVsc2UgaWYgKHZhbHVlLnJlYWRhYmxlICYmIHZhbHVlLmhhc093blByb3BlcnR5KCdodHRwVmVyc2lvbicpKSB7XHJcbiAgICAvLyBvciB0cnkgaHR0cCByZXNwb25zZVxyXG4gICAgZmlsZW5hbWUgPSBwYXRoLmJhc2VuYW1lKHZhbHVlLmNsaWVudC5faHR0cE1lc3NhZ2UucGF0aCB8fCAnJyk7XHJcbiAgfVxyXG5cclxuICBpZiAoZmlsZW5hbWUpIHtcclxuICAgIGNvbnRlbnREaXNwb3NpdGlvbiA9ICdmaWxlbmFtZT1cIicgKyBmaWxlbmFtZSArICdcIic7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gY29udGVudERpc3Bvc2l0aW9uO1xyXG59O1xyXG5cclxuRm9ybURhdGEucHJvdG90eXBlLl9nZXRDb250ZW50VHlwZSA9IGZ1bmN0aW9uKHZhbHVlLCBvcHRpb25zKSB7XHJcblxyXG4gIC8vIHVzZSBjdXN0b20gY29udGVudC10eXBlIGFib3ZlIGFsbFxyXG4gIHZhciBjb250ZW50VHlwZSA9IG9wdGlvbnMuY29udGVudFR5cGU7XHJcblxyXG4gIC8vIG9yIHRyeSBgbmFtZWAgZnJvbSBmb3JtaWRhYmxlLCBicm93c2VyXHJcbiAgaWYgKCFjb250ZW50VHlwZSAmJiB2YWx1ZS5uYW1lKSB7XHJcbiAgICBjb250ZW50VHlwZSA9IG1pbWUubG9va3VwKHZhbHVlLm5hbWUpO1xyXG4gIH1cclxuXHJcbiAgLy8gb3IgdHJ5IGBwYXRoYCBmcm9tIGZzLSwgcmVxdWVzdC0gc3RyZWFtc1xyXG4gIGlmICghY29udGVudFR5cGUgJiYgdmFsdWUucGF0aCkge1xyXG4gICAgY29udGVudFR5cGUgPSBtaW1lLmxvb2t1cCh2YWx1ZS5wYXRoKTtcclxuICB9XHJcblxyXG4gIC8vIG9yIGlmIGl0J3MgaHR0cC1yZXBvbnNlXHJcbiAgaWYgKCFjb250ZW50VHlwZSAmJiB2YWx1ZS5yZWFkYWJsZSAmJiB2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgnaHR0cFZlcnNpb24nKSkge1xyXG4gICAgY29udGVudFR5cGUgPSB2YWx1ZS5oZWFkZXJzWydjb250ZW50LXR5cGUnXTtcclxuICB9XHJcblxyXG4gIC8vIG9yIGd1ZXNzIGl0IGZyb20gdGhlIGZpbGVwYXRoIG9yIGZpbGVuYW1lXHJcbiAgaWYgKCFjb250ZW50VHlwZSAmJiAob3B0aW9ucy5maWxlcGF0aCB8fCBvcHRpb25zLmZpbGVuYW1lKSkge1xyXG4gICAgY29udGVudFR5cGUgPSBtaW1lLmxvb2t1cChvcHRpb25zLmZpbGVwYXRoIHx8IG9wdGlvbnMuZmlsZW5hbWUpO1xyXG4gIH1cclxuXHJcbiAgLy8gZmFsbGJhY2sgdG8gdGhlIGRlZmF1bHQgY29udGVudCB0eXBlIGlmIGB2YWx1ZWAgaXMgbm90IHNpbXBsZSB2YWx1ZVxyXG4gIGlmICghY29udGVudFR5cGUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XHJcbiAgICBjb250ZW50VHlwZSA9IEZvcm1EYXRhLkRFRkFVTFRfQ09OVEVOVF9UWVBFO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGNvbnRlbnRUeXBlO1xyXG59O1xyXG5cclxuRm9ybURhdGEucHJvdG90eXBlLl9tdWx0aVBhcnRGb290ZXIgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gZnVuY3Rpb24obmV4dCkge1xyXG4gICAgdmFyIGZvb3RlciA9IEZvcm1EYXRhLkxJTkVfQlJFQUs7XHJcblxyXG4gICAgdmFyIGxhc3RQYXJ0ID0gKHRoaXMuX3N0cmVhbXMubGVuZ3RoID09PSAwKTtcclxuICAgIGlmIChsYXN0UGFydCkge1xyXG4gICAgICBmb290ZXIgKz0gdGhpcy5fbGFzdEJvdW5kYXJ5KCk7XHJcbiAgICB9XHJcblxyXG4gICAgbmV4dChmb290ZXIpO1xyXG4gIH0uYmluZCh0aGlzKTtcclxufTtcclxuXHJcbkZvcm1EYXRhLnByb3RvdHlwZS5fbGFzdEJvdW5kYXJ5ID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuICctLScgKyB0aGlzLmdldEJvdW5kYXJ5KCkgKyAnLS0nICsgRm9ybURhdGEuTElORV9CUkVBSztcclxufTtcclxuXHJcbkZvcm1EYXRhLnByb3RvdHlwZS5nZXRIZWFkZXJzID0gZnVuY3Rpb24odXNlckhlYWRlcnMpIHtcclxuICB2YXIgaGVhZGVyO1xyXG4gIHZhciBmb3JtSGVhZGVycyA9IHtcclxuICAgICdjb250ZW50LXR5cGUnOiAnbXVsdGlwYXJ0L2Zvcm0tZGF0YTsgYm91bmRhcnk9JyArIHRoaXMuZ2V0Qm91bmRhcnkoKVxyXG4gIH07XHJcblxyXG4gIGZvciAoaGVhZGVyIGluIHVzZXJIZWFkZXJzKSB7XHJcbiAgICBpZiAodXNlckhlYWRlcnMuaGFzT3duUHJvcGVydHkoaGVhZGVyKSkge1xyXG4gICAgICBmb3JtSGVhZGVyc1toZWFkZXIudG9Mb3dlckNhc2UoKV0gPSB1c2VySGVhZGVyc1toZWFkZXJdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGZvcm1IZWFkZXJzO1xyXG59O1xyXG5cclxuRm9ybURhdGEucHJvdG90eXBlLnNldEJvdW5kYXJ5ID0gZnVuY3Rpb24oYm91bmRhcnkpIHtcclxuICB0aGlzLl9ib3VuZGFyeSA9IGJvdW5kYXJ5O1xyXG59O1xyXG5cclxuRm9ybURhdGEucHJvdG90eXBlLmdldEJvdW5kYXJ5ID0gZnVuY3Rpb24oKSB7XHJcbiAgaWYgKCF0aGlzLl9ib3VuZGFyeSkge1xyXG4gICAgdGhpcy5fZ2VuZXJhdGVCb3VuZGFyeSgpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXMuX2JvdW5kYXJ5O1xyXG59O1xyXG5cclxuRm9ybURhdGEucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xyXG4gIHZhciBkYXRhQnVmZmVyID0gbmV3IEJ1ZmZlci5hbGxvYyggMCApO1xyXG4gIHZhciBib3VuZGFyeSA9IHRoaXMuZ2V0Qm91bmRhcnkoKTtcclxuXHJcbiAgLy8gQ3JlYXRlIHRoZSBmb3JtIGNvbnRlbnQuIEFkZCBMaW5lIGJyZWFrcyB0byB0aGUgZW5kIG9mIGRhdGEuXHJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3N0cmVhbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgIGlmICh0eXBlb2YgdGhpcy5fc3RyZWFtc1tpXSAhPT0gJ2Z1bmN0aW9uJykge1xyXG5cclxuICAgICAgLy8gQWRkIGNvbnRlbnQgdG8gdGhlIGJ1ZmZlci5cclxuICAgICAgaWYoQnVmZmVyLmlzQnVmZmVyKHRoaXMuX3N0cmVhbXNbaV0pKSB7XHJcbiAgICAgICAgZGF0YUJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoIFtkYXRhQnVmZmVyLCB0aGlzLl9zdHJlYW1zW2ldXSk7XHJcbiAgICAgIH1lbHNlIHtcclxuICAgICAgICBkYXRhQnVmZmVyID0gQnVmZmVyLmNvbmNhdCggW2RhdGFCdWZmZXIsIEJ1ZmZlci5mcm9tKHRoaXMuX3N0cmVhbXNbaV0pXSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEFkZCBicmVhayBhZnRlciBjb250ZW50LlxyXG4gICAgICBpZiAodHlwZW9mIHRoaXMuX3N0cmVhbXNbaV0gIT09ICdzdHJpbmcnIHx8IHRoaXMuX3N0cmVhbXNbaV0uc3Vic3RyaW5nKCAyLCBib3VuZGFyeS5sZW5ndGggKyAyICkgIT09IGJvdW5kYXJ5KSB7XHJcbiAgICAgICAgZGF0YUJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoIFtkYXRhQnVmZmVyLCBCdWZmZXIuZnJvbShGb3JtRGF0YS5MSU5FX0JSRUFLKV0gKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQWRkIHRoZSBmb290ZXIgYW5kIHJldHVybiB0aGUgQnVmZmVyIG9iamVjdC5cclxuICByZXR1cm4gQnVmZmVyLmNvbmNhdCggW2RhdGFCdWZmZXIsIEJ1ZmZlci5mcm9tKHRoaXMuX2xhc3RCb3VuZGFyeSgpKV0gKTtcclxufTtcclxuXHJcbkZvcm1EYXRhLnByb3RvdHlwZS5fZ2VuZXJhdGVCb3VuZGFyeSA9IGZ1bmN0aW9uKCkge1xyXG4gIC8vIFRoaXMgZ2VuZXJhdGVzIGEgNTAgY2hhcmFjdGVyIGJvdW5kYXJ5IHNpbWlsYXIgdG8gdGhvc2UgdXNlZCBieSBGaXJlZm94LlxyXG4gIC8vIFRoZXkgYXJlIG9wdGltaXplZCBmb3IgYm95ZXItbW9vcmUgcGFyc2luZy5cclxuICB2YXIgYm91bmRhcnkgPSAnLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0nO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMjQ7IGkrKykge1xyXG4gICAgYm91bmRhcnkgKz0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTApLnRvU3RyaW5nKDE2KTtcclxuICB9XHJcblxyXG4gIHRoaXMuX2JvdW5kYXJ5ID0gYm91bmRhcnk7XHJcbn07XHJcblxyXG4vLyBOb3RlOiBnZXRMZW5ndGhTeW5jIERPRVNOJ1QgY2FsY3VsYXRlIHN0cmVhbXMgbGVuZ3RoXHJcbi8vIEFzIHdvcmthcm91bmQgb25lIGNhbiBjYWxjdWxhdGUgZmlsZSBzaXplIG1hbnVhbGx5XHJcbi8vIGFuZCBhZGQgaXQgYXMga25vd25MZW5ndGggb3B0aW9uXHJcbkZvcm1EYXRhLnByb3RvdHlwZS5nZXRMZW5ndGhTeW5jID0gZnVuY3Rpb24oKSB7XHJcbiAgdmFyIGtub3duTGVuZ3RoID0gdGhpcy5fb3ZlcmhlYWRMZW5ndGggKyB0aGlzLl92YWx1ZUxlbmd0aDtcclxuXHJcbiAgLy8gRG9uJ3QgZ2V0IGNvbmZ1c2VkLCB0aGVyZSBhcmUgMyBcImludGVybmFsXCIgc3RyZWFtcyBmb3IgZWFjaCBrZXl2YWwgcGFpclxyXG4gIC8vIHNvIGl0IGJhc2ljYWxseSBjaGVja3MgaWYgdGhlcmUgaXMgYW55IHZhbHVlIGFkZGVkIHRvIHRoZSBmb3JtXHJcbiAgaWYgKHRoaXMuX3N0cmVhbXMubGVuZ3RoKSB7XHJcbiAgICBrbm93bkxlbmd0aCArPSB0aGlzLl9sYXN0Qm91bmRhcnkoKS5sZW5ndGg7XHJcbiAgfVxyXG5cclxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZm9ybS1kYXRhL2Zvcm0tZGF0YS9pc3N1ZXMvNDBcclxuICBpZiAoIXRoaXMuaGFzS25vd25MZW5ndGgoKSkge1xyXG4gICAgLy8gU29tZSBhc3luYyBsZW5ndGggcmV0cmlldmVycyBhcmUgcHJlc2VudFxyXG4gICAgLy8gdGhlcmVmb3JlIHN5bmNocm9ub3VzIGxlbmd0aCBjYWxjdWxhdGlvbiBpcyBmYWxzZS5cclxuICAgIC8vIFBsZWFzZSB1c2UgZ2V0TGVuZ3RoKGNhbGxiYWNrKSB0byBnZXQgcHJvcGVyIGxlbmd0aFxyXG4gICAgdGhpcy5fZXJyb3IobmV3IEVycm9yKCdDYW5ub3QgY2FsY3VsYXRlIHByb3BlciBsZW5ndGggaW4gc3luY2hyb25vdXMgd2F5LicpKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBrbm93bkxlbmd0aDtcclxufTtcclxuXHJcbi8vIFB1YmxpYyBBUEkgdG8gY2hlY2sgaWYgbGVuZ3RoIG9mIGFkZGVkIHZhbHVlcyBpcyBrbm93blxyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZm9ybS1kYXRhL2Zvcm0tZGF0YS9pc3N1ZXMvMTk2XHJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mb3JtLWRhdGEvZm9ybS1kYXRhL2lzc3Vlcy8yNjJcclxuRm9ybURhdGEucHJvdG90eXBlLmhhc0tub3duTGVuZ3RoID0gZnVuY3Rpb24oKSB7XHJcbiAgdmFyIGhhc0tub3duTGVuZ3RoID0gdHJ1ZTtcclxuXHJcbiAgaWYgKHRoaXMuX3ZhbHVlc1RvTWVhc3VyZS5sZW5ndGgpIHtcclxuICAgIGhhc0tub3duTGVuZ3RoID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gaGFzS25vd25MZW5ndGg7XHJcbn07XHJcblxyXG5Gb3JtRGF0YS5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24oY2IpIHtcclxuICB2YXIga25vd25MZW5ndGggPSB0aGlzLl9vdmVyaGVhZExlbmd0aCArIHRoaXMuX3ZhbHVlTGVuZ3RoO1xyXG5cclxuICBpZiAodGhpcy5fc3RyZWFtcy5sZW5ndGgpIHtcclxuICAgIGtub3duTGVuZ3RoICs9IHRoaXMuX2xhc3RCb3VuZGFyeSgpLmxlbmd0aDtcclxuICB9XHJcblxyXG4gIGlmICghdGhpcy5fdmFsdWVzVG9NZWFzdXJlLmxlbmd0aCkge1xyXG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYi5iaW5kKHRoaXMsIG51bGwsIGtub3duTGVuZ3RoKSk7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBhc3luY2tpdC5wYXJhbGxlbCh0aGlzLl92YWx1ZXNUb01lYXN1cmUsIHRoaXMuX2xlbmd0aFJldHJpZXZlciwgZnVuY3Rpb24oZXJyLCB2YWx1ZXMpIHtcclxuICAgIGlmIChlcnIpIHtcclxuICAgICAgY2IoZXJyKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uKGxlbmd0aCkge1xyXG4gICAgICBrbm93bkxlbmd0aCArPSBsZW5ndGg7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjYihudWxsLCBrbm93bkxlbmd0aCk7XHJcbiAgfSk7XHJcbn07XHJcblxyXG5Gb3JtRGF0YS5wcm90b3R5cGUuc3VibWl0ID0gZnVuY3Rpb24ocGFyYW1zLCBjYikge1xyXG4gIHZhciByZXF1ZXN0XHJcbiAgICAsIG9wdGlvbnNcclxuICAgICwgZGVmYXVsdHMgPSB7bWV0aG9kOiAncG9zdCd9XHJcbiAgICA7XHJcblxyXG4gIC8vIHBhcnNlIHByb3ZpZGVkIHVybCBpZiBpdCdzIHN0cmluZ1xyXG4gIC8vIG9yIHRyZWF0IGl0IGFzIG9wdGlvbnMgb2JqZWN0XHJcbiAgaWYgKHR5cGVvZiBwYXJhbXMgPT0gJ3N0cmluZycpIHtcclxuXHJcbiAgICBwYXJhbXMgPSBwYXJzZVVybChwYXJhbXMpO1xyXG4gICAgb3B0aW9ucyA9IHBvcHVsYXRlKHtcclxuICAgICAgcG9ydDogcGFyYW1zLnBvcnQsXHJcbiAgICAgIHBhdGg6IHBhcmFtcy5wYXRobmFtZSxcclxuICAgICAgaG9zdDogcGFyYW1zLmhvc3RuYW1lLFxyXG4gICAgICBwcm90b2NvbDogcGFyYW1zLnByb3RvY29sXHJcbiAgICB9LCBkZWZhdWx0cyk7XHJcblxyXG4gIC8vIHVzZSBjdXN0b20gcGFyYW1zXHJcbiAgfSBlbHNlIHtcclxuXHJcbiAgICBvcHRpb25zID0gcG9wdWxhdGUocGFyYW1zLCBkZWZhdWx0cyk7XHJcbiAgICAvLyBpZiBubyBwb3J0IHByb3ZpZGVkIHVzZSBkZWZhdWx0IG9uZVxyXG4gICAgaWYgKCFvcHRpb25zLnBvcnQpIHtcclxuICAgICAgb3B0aW9ucy5wb3J0ID0gb3B0aW9ucy5wcm90b2NvbCA9PSAnaHR0cHM6JyA/IDQ0MyA6IDgwO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gcHV0IHRoYXQgZ29vZCBjb2RlIGluIGdldEhlYWRlcnMgdG8gc29tZSB1c2VcclxuICBvcHRpb25zLmhlYWRlcnMgPSB0aGlzLmdldEhlYWRlcnMocGFyYW1zLmhlYWRlcnMpO1xyXG5cclxuICAvLyBodHRwcyBpZiBzcGVjaWZpZWQsIGZhbGxiYWNrIHRvIGh0dHAgaW4gYW55IG90aGVyIGNhc2VcclxuICBpZiAob3B0aW9ucy5wcm90b2NvbCA9PSAnaHR0cHM6Jykge1xyXG4gICAgcmVxdWVzdCA9IGh0dHBzLnJlcXVlc3Qob3B0aW9ucyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJlcXVlc3QgPSBodHRwLnJlcXVlc3Qob3B0aW9ucyk7XHJcbiAgfVxyXG5cclxuICAvLyBnZXQgY29udGVudCBsZW5ndGggYW5kIGZpcmUgYXdheVxyXG4gIHRoaXMuZ2V0TGVuZ3RoKGZ1bmN0aW9uKGVyciwgbGVuZ3RoKSB7XHJcbiAgICBpZiAoZXJyICYmIGVyciAhPT0gJ1Vua25vd24gc3RyZWFtJykge1xyXG4gICAgICB0aGlzLl9lcnJvcihlcnIpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYWRkIGNvbnRlbnQgbGVuZ3RoXHJcbiAgICBpZiAobGVuZ3RoKSB7XHJcbiAgICAgIHJlcXVlc3Quc2V0SGVhZGVyKCdDb250ZW50LUxlbmd0aCcsIGxlbmd0aCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5waXBlKHJlcXVlc3QpO1xyXG4gICAgaWYgKGNiKSB7XHJcbiAgICAgIHZhciBvblJlc3BvbnNlO1xyXG5cclxuICAgICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gKGVycm9yLCByZXNwb25jZSkge1xyXG4gICAgICAgIHJlcXVlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgY2FsbGJhY2spO1xyXG4gICAgICAgIHJlcXVlc3QucmVtb3ZlTGlzdGVuZXIoJ3Jlc3BvbnNlJywgb25SZXNwb25zZSk7XHJcblxyXG4gICAgICAgIHJldHVybiBjYi5jYWxsKHRoaXMsIGVycm9yLCByZXNwb25jZSk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBvblJlc3BvbnNlID0gY2FsbGJhY2suYmluZCh0aGlzLCBudWxsKTtcclxuXHJcbiAgICAgIHJlcXVlc3Qub24oJ2Vycm9yJywgY2FsbGJhY2spO1xyXG4gICAgICByZXF1ZXN0Lm9uKCdyZXNwb25zZScsIG9uUmVzcG9uc2UpO1xyXG4gICAgfVxyXG4gIH0uYmluZCh0aGlzKSk7XHJcblxyXG4gIHJldHVybiByZXF1ZXN0O1xyXG59O1xyXG5cclxuRm9ybURhdGEucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uKGVycikge1xyXG4gIGlmICghdGhpcy5lcnJvcikge1xyXG4gICAgdGhpcy5lcnJvciA9IGVycjtcclxuICAgIHRoaXMucGF1c2UoKTtcclxuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xyXG4gIH1cclxufTtcclxuXHJcbkZvcm1EYXRhLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gJ1tvYmplY3QgRm9ybURhdGFdJztcclxufTtcclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/form-data/lib/form_data.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/form-data/lib/populate.js":
/*!************************************************!*\
  !*** ./node_modules/form-data/lib/populate.js ***!
  \************************************************/
/***/ ((module) => {

eval("// populates missing values\r\nmodule.exports = function(dst, src) {\r\n\r\n  Object.keys(src).forEach(function(prop)\r\n  {\r\n    dst[prop] = dst[prop] || src[prop];\r\n  });\r\n\r\n  return dst;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZm9ybS1kYXRhL2xpYi9wb3B1bGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxceGFtcHBcXGh0ZG9jc1xcRHVBblRvdE5naGllcFxcSG9zdGluZ1xcdGVjaHN0dWRlbnQtZGF0biAtIENvcHlcXGFhYWFhYWFhYWFcXExvY2R1YW50b3ROZ2hpZXBcXExvY2R1YW50b3ROZ2hpZXBcXG5vZGVfbW9kdWxlc1xcZm9ybS1kYXRhXFxsaWJcXHBvcHVsYXRlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHBvcHVsYXRlcyBtaXNzaW5nIHZhbHVlc1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRzdCwgc3JjKSB7XHJcblxyXG4gIE9iamVjdC5rZXlzKHNyYykuZm9yRWFjaChmdW5jdGlvbihwcm9wKVxyXG4gIHtcclxuICAgIGRzdFtwcm9wXSA9IGRzdFtwcm9wXSB8fCBzcmNbcHJvcF07XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiBkc3Q7XHJcbn07XHJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/form-data/lib/populate.js\n");

/***/ })

};
;